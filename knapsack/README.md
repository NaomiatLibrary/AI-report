# 人工知能　レポート問題　問題09
## 1.問題
以下のメタヒューリスティクス手法のうち１つ以上(できれば２つ)を選んで、簡単にアルゴリズムを説明したのち、ナップザック問題に適用してその性能を比較してみよ。
1. ホップフィールドネットワーク：Hopfield networks
2. 花火アルゴリズム：Fireworks algorithm
3. クジラ探索：Whale optimization algorithm
4. カエル探索：Shuffled Frog-Leaping Algorithm (SFLA)
### 01ナップザック問題とは
ナップザック問題とは、商品ごとの重さと価値、またナップザックの容量が与えられ、ナップザックの容量を超えないように商品を詰める詰め方のうちもっとも詰めた商品の価値の合計が高くなる詰め方を求める問題、またはこのような問題に帰着できる問題のことである。
01ナップザック問題ではそれぞれの商品は0個または1個のみナップザックに入れることができる。
## 2.ソースコードの動かし方
### カエル探索
problemsフォルダ内に[https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html](https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html)から問題ファイルをダウンロードしておく。
`python frog.py p01`（p01は適宜解かせたい問題番号に変える）で実行すると、10回カエル探索が行われ、その結果が最終行に`成功回数　最大スコア　最小スコア　平均スコア 分散`の順で表示される。途中経過として、一回探索が行われるごとに`[その時点での最適解] 価値の和　重さの和　容量`が示される。

### クジラ探索

problemsフォルダ内に[https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html](https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html)から問題ファイルをダウンロードしておく。
`python whale.py p01`（p01は適宜解かせたい問題番号に変える）で実行すると、10回クジラ探索が行われ、その結果が最終行に`成功回数　最大スコア　最小スコア　平均スコア　分散　`の順で表示される。途中経過として、一回探索が行われるごとに`[その時点での最適解] 価値の和　重さの和　容量`が示される。

## 3.実装方針
### カエル探索：シャッフルカエル跳躍アルゴリズム(SFLA)
食料がたくさんある場所を探すカエルの集団の行動をモデルとしたメタヒューリスティック最適化手法である。memeplexと呼ばれている部分集合に分けられたカエルの集合が存在する。memeplexそれぞれの中にはカエルの個体が存在し、その持っている解法は他のカエルの解法に影響され、模倣進化をして進化していく（局所的探索）。決まった回数の模倣進化のステップが終わると、解法はmemeplexesの間で共有される（shuffling process）。局所的探索とshuffling processが定められた収斂基準を満たすまで繰り返される。

01ナップザック問題用に改変されたModified Discrete Shuffled Frog Leaping Algorithm(MDSFLA)の具体的な実装としては以下になる。

1. P匹のカエルがランダムに生成される。商品の個数がN個の問題の場合、カエルiは$X_i=(x_{i1},x_{i2},...x_{iN}),i=1...P,x_{ij}\in(0,1)$で定義される。

2. カエルが適合度で降順にソートされる。適合度は今回改良されたquadratic penalty$f(x)=p\cdot x - ( \max(0,\rho(\mathbb{w}\times\mathbb{x}^T-b)) )^2,\rho=\max_{i=1...N}(p_i/w_i)$を用いた。

3. 全体がm個のmemeplexに分割され、それぞれがn匹のカエルを持つ（P=nm)。この時、1番目のカエルは1番目のmemeplexに、2番目のカエルは2番目のmemeplexに…というふうに割り振る。

4. それぞれのmemeplexのなかでもっとも適合度が高い・低いカエルを$X_b,X_w$として、全体でもっとも高いカエルを$X_g$とする。$X_w$のみを改善する。改善方法は以下。
   $X_w\leftarrow X_w+D_i,D_i=Rand(0,1)\times(X_b-X_w)$

5. これにより改善されるときはそれで$X_w$を置き換え、改善しないときは$X_g$を使って繰り返す。

6. それでも改善されない時は$X_wを$ランダムな結果で置き換える。

7. 決まった回数の模倣進化 （4~6）を繰り返す。

8. memeplexを合体する。

9. 突然変異を適用する。

10. この時点で最高の適合率を持つものを一時的な解とする。この解が一定回数変更されていない場合、探索を終了とし、解を返す。そうでない場合、2~9を繰り返す。

    

今回の実装ではカエルの個体数は500、memeplexの数は10、memeplex内での進化の回数は100、突然変異の確率は0.06とした。また、解が7回連続で更新されていない時に終了することとした。

#### 論文に書いてない工夫を施したところ

今回、論文内に示されている評価関数のうち論文中(10)のquadratic penaltyを用いたが、そのまま用いたところ二次関数のペナルティ項が影響を持ちすぎて最適解ではなく重量いっぱいに詰め込む解が出てしまうことが多々あった。
そこで、ペナルティ項の内部$\rho(\mathbb{w}\times\mathbb{x}^T-b)$が正の時のみ、ペナルティ項を適用することにした。
この改善により明らかに出力が向上した。

### クジラ探索:Opposition-based learning Whale Optimization Algorithm (OWOA)

鯨の捕食活動を模倣したアルゴリズムであるWhale Optimization Algorithm(WOA)と、Opposition-Based Learning(OBL)を組み合わせたアルゴリズムである。

WOAアルゴリズムにおいて、クジラの位置$x$の更新は以下のようなステップに則って行われる。$B$はクジラの中で制約を満たすかつもっとも価値の合計が良いクジラのベクトルを表す。

1. 獲物に近づいていくモデル：$x^{t+1}=B-A.D$、ただし$D=|C.B-x^t|,A=2a.r_1-a,C=2.r_2$、ここで$r_1,r_2$はランダムに生成された要素が$[0,1)$のベクトル、aは探索回数に応じて2から0に向かって線形に小さくなっていく数。
2. 螺旋を描くモデル：$x^{t+1}=D'.e^{bl}.\cos(2\pi l)+B$、ただし$D'=|B-x^t|$、$b$は螺旋の形を決定する定数であり$l$は$[-1,1]$のランダムに生成された数である。
3. 獲物の探索：$x^{t+1}=X_{rand}-A.D$、ただし$D=|C.X_{rand}-x^t|$、$X_{rand}$はランダムなクジラの位置で$A$は絶対値が1より大きい要素を持つランダムなベクトル。

基本的にステップ1と2を50%ずつの確率で行い、ステップ3を定められた割合で行う。

01ナップザック問題用に改変されたOWOAの具体的な実装としては以下になる。

1. P匹のクジラがランダムに生成される。商品の個数がN個の問題の場合、クジラiは$X_i=(x_{i1},x_{i2},...x_{iN}),i=1...P,x_{ij}\in(0,1)$で定義される。さらに、このクジラは
2. クジラごとに価値の合計を計算する
3. 論理的否定をとることによってopposite locationを計算する
4. もしopposite locationが容量の制約を満たしていれば、その価値の合計を計算する。
5. opposite vectorの値が元のクジラの値を超えていて、かつ現在のもっとも良いクジラの値を超えていれば、もっとも良いクジラの値をそれで置き換える。
6. 元のクジラの値がopposite vectorの値を超えていて、かつ現在のもっとも良いクジラの値を超えていれば、もっとも良いクジラの値をそれで置き換える。
7. WOAアルゴリズムによりクジラの位置の更新が行われる。
8. 最大繰り返し回数に達するまで1-7が繰り返される

#### 離散化

このままではOWOAアルゴリズムによる更新を行う際に$x_{ij}\in (0,1)$を満たさなくなってしまう。この問題を解決する方法が論文に詳しく載っていなかったので、今回はクジラの位置には任意の実数を許すこととして、ステップ2-6(価値の合計を計算〜もっとも良いクジラの値の更新)においてのみ0.5以下の値を0、0.5以上の値を1に丸めることで離散化を行なった。

## 4.結果・考察
### カエル探索
以下に[KNAPSACK_01](https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html)のp01,p07,p08での実行結果を載せる。10回実行した上で、成功回数（重さの制約を満たす解が出た回数）と最高スコア・最低スコア・平均スコア・標準偏差を計算した。
どの問題においても最高スコアとしてはサイトに掲載されている最適解と同じものを出力している。
解が改善される過程については、付属資料に示した。

|問題|成功回数|最高スコア|最低スコア|平均スコア| 標準偏差    |理論値|
|----|----|----|----|----|----|----|
|p01|10|309|309|309| 0           |309|
|p07|10|1458|1458|1458| 0           |1458|
|p08|10|13549094|13467914|13514105.7|23263.06559|13549094|
### クジラ探索

以下に[KNAPSACK_01](https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html)のp01,p07,p08での実行結果を載せる。10回実行した上で、成功回数（重さの制約を満たす解が出た回数）と最高スコア・最低スコア・平均スコアを計算した。

| 問題 | 成功回数 | 最高スコア | 最低スコア | 平均スコア | 標準偏差           | 理論値   |
| ---- | -------- | ---------- | ---------- | ---------- | ------------------ | -------- |
| p01  | 10       | 309        | 284        | 306.5      | 7.5                | 309      |
| p07  | 10       | 1453       | 1441       | 1448.0     | 3.3763886032130346 | 1458     |
| p08  | 10       | 13206090   | 13032302   | 13130036.9 | 48478.3787669823   | 13549094 |

### 結果の比較

クジラ探索を行なった場合より、明らかにカエル探索を行なった場合の方が性能が良かった。

今回用いたカエル探索に比べて、クジラ探索は十分に離散化されていないアルゴリズムだからであると考えられる。クジラ探索はN次元空間上で螺旋を描くようにターゲットへと近づく探索方法であるが、今回の問題では各次元で許される値が0と1しかないため、この動きがうまくできず解にたどりつきにくいのではないかと思った。一方でカエル探索では、解空間上を離散的にジャンプしながら最適解を探せるので、今回の問題に適していると思った。ただし、クジラ探索において離散化をどうするのかという部分が論文に書いていなかったため、想定された探索方法と違いがあったからである可能性が高い。

## 5.付属資料：カエル探索で解が改善していく過程の確認

p01,p07,p08で解が改善されていく過程を貼る。
探索により、解が改善されていくのがわかる。

### p01
```
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
[1 1 1 1 0 1 0 0 0 0] 309 165 165
```
### p07
```
[1 1 1 0 1 0 0 1 0 0 0 0 1 1 1] 1453 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
[1 0 1 0 1 0 1 1 1 0 0 0 0 1 1] 1458 749 750
```
### p08
```
[1 0 0 0 1 1 1 0 1 1 1 0 0 1 1 1 1 1 0 0 0 0 0 0] 13234012 6390786 6404180
[1 0 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 1 0 1 0 0 0 1] 13348855 6393290 6404180
[1 0 0 1 1 0 1 0 0 1 1 0 1 0 1 1 1 1 0 1 0 0 0 1] 13348855 6393290 6404180
[1 0 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 1 1] 13420009 6397455 6404180
[1 0 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 1 1] 13420009 6397455 6404180
[1 0 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 1 1] 13420009 6397455 6404180
[1 0 0 1 1 1 1 0 1 1 1 0 0 0 1 1 1 0 0 0 0 0 1 1] 13420009 6397455 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
[1 1 0 1 1 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 1 1 1] 13549094 6402560 6404180
```

